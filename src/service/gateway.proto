syntax = "proto3";

package helium;

import "blockchain_state_channel_v1.proto";
import "blockchain_txn_state_channel_close_v1.proto";

enum CloseState {
  close_state_closable = 0;
  close_state_closing = 1;
  close_state_closed = 2;
  close_state_dispute = 3;
}

/* general */

message empty {
}

message success_resp {
  bytes resp = 1;
}

message error_resp {
  bytes error = 1;
  bytes reason = 2
}

message resp {
  oneof msg {
    success_resp success_resp = 1;
    error_resp error_resp = 2;
  }
}

message gateway_stream_req_v1 {
  oneof msg {
    gateway_sc_follow_req_v1 follow_req = 1;
    gateway_routing_req_v1 routing_req = 2;
    gateway_poc_get_challenge_req_v1 get_challenge_req = 3;
  }
}

message gateway_resp_v1 {
  uint64 height = 1;
  bytes signature = 2;
  oneof msg {
    gateway_sc_is_valid_resp_v1 sc_is_valid_resp = 3;
    gateway_sc_close_resp_v1 sc_close_resp = 4;
    gateway_sc_follow_streamed_resp_v1 sc_follow_streamed_resp = 5;
    gateway_routing_streamed_resp_v1 routing_streamed_resp = 6;
    gateway_poc_challenge_payload_resp_v1_pb poc_challenge_resp = 7;
    gateway_poc_witness_target_resp_v1_pb poc_witness_target_resp = 8;
  }
}

/* state channels */

message gateway_sc_is_valid_req_v1 { blockchain_state_channel_v1 sc = 1; }
message gateway_sc_is_valid_resp_v1 {
  bytes sc_id = 1;
  bool valid = 2;
  bytes reason = 3;
}

message gateway_sc_close_req_v1 {
  blockchain_txn_state_channel_close_v1 close_txn = 1;
}
message gateway_sc_close_resp_v1 {
  bytes sc_id = 1;
  bytes response = 2;
}

message gateway_sc_follow_req_v1 {
  bytes sc_id = 1;
  bytes owner = 2;
}
message gateway_sc_follow_streamed_resp_v1 {
  bytes sc_id = 1;
  CloseState close_state = 2;
}

/* routing */

message routing {
  uint32 oui = 1;
  bytes owner = 2;
  repeated routing_address addresses = 3;
  repeated bytes filters = 4;
  repeated bytes subnets = 5;
}

message routing_address {
  bytes pub_key = 1;
  bytes uri = 2;
}

message gateway_routing_req_v1 { uint64 height = 1; }
message gateway_routing_streamed_resp_v1 { repeated routing routings = 1; }

/* POCs */

// streaming notification sent by a validator to a light gateway to notify it of a new challenge
message gateway_poc_challenge_notification_resp_v1 {
  routing_address challenger = 1;                     // routing info of the challenging validator
  bytes block_hash = 2;                               // block hash of the block which contains the POC request
  bytes secret_hash = 3                               // hash of the POC's secret
  bytes onion_hash = 4                               // hash of the POC's onion
}

// request sent by a light gateway to a challenging validator in order to retrieve the challenge payload
message gateway_poc_get_challenge_req_v1 {
  bytes address = 1;                                  // address of the challengee
  bytes challenger = 2                                // address of the challenger
  uint64 height = 3;                                  // height provided by the notifying validator in the 'gateway_poc_challenge_notification_resp_v1' msg
  bytes block_hash = 4;                               // block hash provided by the notifying validator in the 'gateway_poc_challenge_notification_resp_v1' msg
  bytes secret_hash = 5;                              // secret hash provided by the notifying validator in the 'gateway_poc_challenge_notification_resp_v1' msg
  bytes onion_hash = 6;                               // onion hash provided by the notifying validator in the 'gateway_poc_challenge_notification_resp_v1' msg
  bytes notifier = 7;                                 // address of the notifying validator, derived from the 'gateway_poc_challenge_notification_resp_v1' msg
  bytes notifier_sig = 8;                             // the signature payload derived from the 'gateway_resp_v1' msg containing the 'gateway_poc_challenge_notification_resp_v1' msg
}

// response containing the challenge payload to the clients 'gateway_poc_get_challenge_req_v1' request
message gateway_poc_challenge_payload_resp_v1 {
  bytes onion = 1
}

// request sent by a light gateway to its durable validator in order to retrieve a consensus group member to which it should forward witness reports
message gateway_poc_get_witness_target_req_v1 {
  bytes address = 1;                                // address of the observing GW
  bytes onion_hash = 2;                             // the onion hash derived from the observed packet
}

// response containing the consensus group member's routing info to the clients 'gateway_poc_get_witness_req_v1' request
message gateway_poc_witness_target_resp_v1 {
  routing_address address = 1;                      // routing info of the CG member the observing GW is to send the witness report too
}

// request sent by a light gateway to a consensus group member containing the observing gateways witness report
message gateway_poc_witness_report_req_v1 {
  blockchain_poc_witness_v1_pb witness = 1;         // the signed witness report from the observing GWs
  bytes notifier = 2;                               // address of the notifying validator which provided the 'gateway_poc_witness_resp_v1 msg
  bytes notifier_sig = 3;                           // the signature payload derived from the 'gateway_resp_v1' msg containing the 'gateway_poc_witness_resp_v1' msg
}

// request sent by a light gateway to a consensus group member containing the challengee's gateways receipt report
message gateway_poc_receipt_req_v1 {
  blockchain_poc_receipt_v1_pb receipt = 1;       // the signed receipt report from the observing GWs
  bytes notifier = 2;                             // address of the notifying validator derived from the 'gateway_resp_v1' msg containing the 'gateway_poc_challenge_notification_resp_v1' msg
  bytes notifier_sig = 3;                         // the signature payload derived from the 'gateway_resp_v1' msg containing the 'gateway_poc_challenge_notification_resp_v1' msg
}


/* Gateway Service */

service gateway {
  rpc stream(stream gateway_stream_req_v1) returns (stream gateway_resp_v1);

  rpc is_valid(gateway_sc_is_valid_req_v1) returns (gateway_resp_v1);
  rpc close(gateway_sc_close_req_v1) returns (gateway_resp_v1);

  rpc routing(gateway_routing_req_v1) returns (stream gateway_resp_v1);

  rpc get_challenge(gateway_poc_get_challenge_req_v1) returns (gateway_resp_v1);
  rpc get_witness_target(gateway_poc_get_witness_target_req_v1) returns (gateway_poc_witness_target_resp_v1);
  rpc send_witness(gateway_poc_witness_report_req_v1) returns (resp);
  rpc send_receipt(gateway_poc_receipt_req_v1) returns (resp);
}